---
description: 제 3장 모든 객체의 공통 메서드
---

# 3. 모든 객체의 공통 메서드

### 아이템 10 - equals는 일반 규약을 지켜 재정의하라.

equals 메서드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 자칫하면 안좋은 결과를 초래한다. 문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다. 아래와 같은 경우는 재정의하지 않는 것이 좋다.

* **각 인스턴스가 본질적으로 고유하다.** 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. 좋은 예로 Thread가 있다.
* **인스턴스의 '논리적 동치성\(logical equality\)'를 검사할 일이 없다.** 예컨대 java.util.regex.Pettern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는, 즉 논리적 동치성을 검사하는 방법도 있다. 즉 Object의 기본 equals만으로 해결된다.
* **상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.** 대부분의 Set 구현체는 AbstractSet이 구현한 equlas를 상속받아 쓰고, List는 AbstractList, Map은 AbstractMap으로부터 상속받아 그대로 쓴다.
* **클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.**

그렇다면 equals를 재정의해야 할 때는 언제인가? 바로 '객체 식별성\(두 객체가 물리적으로 같은가\)'이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다. 주로 값 클래스들이 여기 해당한다.

두 값의 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어 할 것이다. equals가 논리적 동치성을 화긴하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함과 Map의 키와 Set의 원소로 사용할 수 있게 된다.

값 클래스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. 인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같기 때문이다.\(ex\) Enum\) equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다. 아래는 Object 명세에 적힌 규약이다.

**equals 메서드는 동치관계를 구현하며, 다음을 만족한다.**

* 반사성\(reflexivity\): null이 아닌 모든 참조 값 x에 대해, x.equals\(x\)는 true이다.
* 대칭성\(symmetry\): null이 아닌 모든 참조 값 x, y에 대해, x.equals\(y\)가 true면 y.equals\(x\)도 true다.
* 추이성\(transitivity\): null이 아닌 모든 참조 값 x, y, z에 대해, x.eqauls\(y\)가 true이고 y.equals\(z\)도 true면 x.equals\(x\)도 true다.
* 일관성\(consistency\): null 이 아닌 모든 참조 값 x, y에 대해 x.equals\(y\)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
* null-아님: null이 아닌 모든 참조 값 x에 대해, x.equals\(null\)은 false다.

equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다. 아래는 동치관계를 만족시키기 위한 다섯가지 요건이다.

**반사성**은 단순하게 객체는 자기 자신과 같아야 한다는 뜻이다. 이 요건을 어긴 클래스의 인스턴스를 컬렉션에 넣은 다음 contains 메서드를 호출하면 방금 넣은 인스턴스가 없다고 답할 것이다.

대칭성은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 뜻이다. 반사성 요건과 달리 대칭성 요건은 자칫하면 어길 수 있어 보인다. 대소문자를 구별하지 않는 문자열을 구현한 다음 클래스를 예로 살펴보자.

 

### 아이템 11 - equals를 재정의하려거든 hashCode도 재정의하라.

### 아이템 12 - toString을 항상 재정의하라.

* Object의 기본 toString 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.
* 보통 PhoneNumber@abbbd처럼 단순히 **클래스\_이름@16진수\_해시코드**를 반환할 뿐이다. 
* toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다.
* 따라서 모든 하위 클래스에서 이 메서드를 재정의해야한다. toString을 잘 구현한 클래스는 사용하기에 훨씬 좋고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
* **toString 메서드는 객체를 println, printf, 문자열 연결 연산자\(+\), assert 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다.**
* 아래와 같이 toString을 제대로 재정의했다면 다음 코드만으로 문제를 진단하기에 충분한 메세지를 남길수 있다.

  ```java
  System.out.println(phoneNumber + "에 연결할 수 없습니다.");
  ```

* **실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.** 하지만 객체가 거대하거나, 객체의 상태가 문자열로 표현하기에 적합하지 않다면 무리가 있다. 이런 상황이라면 "맨하튼 거주자 전화번호부\(총 1000개\)" 나 "Thread\[main,5,main\]" 같은 요약 정보를 담아야 한다.
* toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야한다. 이것은 아주 중요한 선택이다.
* 포맷을 명시하기로 했다면, 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리나 생성자를 함께 제공해주면 좋다. 좋은예로 BigInteger, BigDecimal과 대부분의 기본 타입 클래스가 여기 해당한다.
* 하지만 단점도 있다. 포맷을 한번 명시하면 평생 그 포맷에 얽매이게되고 향후 릴리즈에서 포맷을 바꾼다면 사용하던 코드들과 데이터들은 엉망이 될 것이다.
* **포맷을 명시하든 아니든 우리의 의도는 명확히 밝혀야 한다.**

  ```java
  // 포맷을 명시하기로 한 경우
  /**
   * 이 전화번호의 문자열 표현을 반환한다.
   * 이 문자열은 "XXX-YYY-ZZZZ" 형태의 12글자로 구성된다.
   * XXX는 지역 코드, YYY는 프리픽스, ZZZZ는 가입자 번호다.
   * 각각의 대문자는 10진수 숫자 하나를 나타낸다.
   *
   * 전화번호의 각 부분의 값이 너무 작아서 자릿수를 채울 수 없다면,
   * 앞에서부터 0으로 채워나간다. 예컨대 가입자 번호가 123이라면
   * 전화번호의 마지막 네 문자는 "0123"이 된다.
   */
  @Override public String toString() {
      return String.format("%03d-%03d-%04d",
              areaCode, prefix, lineNum);
  }

  // 포맷을 명시하지 않기로 한 경우
  /**
   * 상세형식은 정해지지 않았으며 향후 변경될 수 있다. 
   */
  @Override public String toString() {...}
  ```

* **포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올수 있는 API를 제공하자.**
* 위 예제로 보면 PhoneNumber 클래스는 지역코드, 프리픽스, 가입자번호 접근자를 제공해야 한다.
* 정적 유틸리티 클래스나 대부분의 열거 타입도 자바가 이미 완벽한 toString을 제공하니 따로 재정의하지 않아도 된다.
* 하지만 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상클래스라면 toString을 재정의해줘야 한다.

#### 결론

* 모든 구체 클래스에서 Object의 toString을 재정의하자. 상위 클래스에서 이미 알맞게 정의한 경우는 예외이다.
* toString을 재정의한 클래스는 사용하기도 즐겁고, 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다.
* toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.



